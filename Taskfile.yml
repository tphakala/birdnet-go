version: '3'

vars:
  BINARY_DIR: bin
  BINARY_NAME: birdnet-go
  TFLITE_VERSION: v2.17.1
  LABELS_DIR: internal/birdnet/data/labels
  AVICOMMONS_DATA_DIR: internal/imageprovider/data
  AVICOMMONS_JSON_FILE: latest.json
  AVICOMMONS_JSON_URL: https://avicommons.org/latest.json
  BUILD_DATE:
    sh: date -u +%Y-%m-%dT%H:%M:%SZ
  VERSION:
    sh: |
      if [ ! -z "$BUILD_VERSION" ]; then
        echo "$BUILD_VERSION"
      else
        git describe --tags --always 2>/dev/null || echo "unknown"
      fi
  UNAME_S:
    sh: uname -s
  UNAME_M:
    sh: uname -m
  # Common build flags
  CGO_FLAGS: CGO_ENABLED=1 CGO_CFLAGS="-I$HOME/src/tensorflow"
  BUILD_FLAGS: -ldflags "-s -w -X 'main.buildDate={{.BUILD_DATE}}' -X 'main.version={{.VERSION}}'"
  # System paths
  SYSTEM_LIB_DIR_AMD64: /usr/lib
  SYSTEM_LIB_DIR_ARM64: /usr/aarch64-linux-gnu/lib

tasks:
  default:
    deps: [native-target]

  # Task for running tests
  test:
    desc: Run tests for the application
    cmds:
      # Use noembed tag to skip frontend embedding requirement for faster tests
      - go test -tags noembed ./... {{.TEST_FLAGS}}
    vars:
      TEST_FLAGS: '{{default "" .CLI_ARGS}}'

  # Task for running tests with verbose output
  test-verbose:
    desc: Run tests with verbose output
    cmds:
      - task: test
        vars: {CLI_ARGS: "-v"}

  # Task for running tests with coverage report
  test-coverage:
    desc: Run tests with coverage report
    cmds:
      - mkdir -p coverage
      # Use noembed tag to skip frontend embedding requirement for faster tests
      - go test -tags noembed ./... -coverprofile=coverage/coverage.out {{.TEST_FLAGS}}
      - go tool cover -html=coverage/coverage.out -o coverage/coverage.html
    vars:
      TEST_FLAGS: '{{default "" .CLI_ARGS}}'

  # Go linting with CGO support for TensorFlow
  lint:
    desc: Run golangci-lint with TensorFlow CGO flags
    cmds:
      - |
        # Determine library path based on OS
        if [ "{{.UNAME_S}}" = "Darwin" ]; then
          if [ "{{.UNAME_M}}" = "arm64" ]; then
            LIB_DIR="/opt/homebrew/lib"
          else
            LIB_DIR="/usr/local/lib"
          fi
        else
          LIB_DIR="/usr/lib"
        fi
        # Use noembed tag to skip frontend embedding requirement for faster linting
        {{.CGO_FLAGS}} CGO_LDFLAGS="-L${LIB_DIR} -ltensorflowlite_c" \
        golangci-lint run --build-tags=noembed {{.CLI_ARGS}}
    vars:
      CLI_ARGS: '{{default "-v" .CLI_ARGS}}'

  lint-fix:
    desc: Run golangci-lint with auto-fix enabled
    cmds:
      - task: lint
        vars: {CLI_ARGS: "--fix -v"}

  # New Task: Download Avicommons Data
  download-avicommons-data:
    desc: Download the Avicommons latest.json data file if it doesn't exist
    dir: '{{.AVICOMMONS_DATA_DIR}}'
    cmds:
      - mkdir -p {{.AVICOMMONS_DATA_DIR}}
      - |
        if [ ! -f "{{.AVICOMMONS_JSON_FILE}}" ]; then
          echo "Downloading Avicommons data file ({{.AVICOMMONS_JSON_FILE}})..."
          # Use curl with -fL to fail on error and follow redirects
          curl -fL -o "{{.AVICOMMONS_JSON_FILE}}" "{{.AVICOMMONS_JSON_URL}}"
        else
          echo "Avicommons data file ({{.AVICOMMONS_JSON_FILE}}) already exists."
        fi
    status:
      - '[ -f "{{.AVICOMMONS_JSON_FILE}}" ]'

  native-target:
    cmds:
      - |
        if [ "{{.OS}}" = "unsupported" ] || [ "{{.ARCH}}" = "unsupported" ]; then
          echo "Error: Unsupported platform combination: OS={{.OS}}, ARCH={{.ARCH}}"
          exit 1
        fi
      - task: "{{OS}}_{{ARCH}}"
    vars:
      OS:
        sh: |
          case "{{.UNAME_S}}" in
            Linux) echo "linux";;
            Darwin) echo "darwin";;
            *) echo "unsupported";;
          esac
      ARCH:
        sh: |
          case "{{.UNAME_M}}" in
            x86_64) echo "amd64";;
            aarch64|arm64) echo "arm64";;
            *) echo "unsupported";;
          esac

  setup-dev:
    desc: Setup development environment on Linux (apt) or macOS (homebrew)
    cmds:
      - |
        echo "ðŸš€ BirdNET-Go Development Environment Setup"
        echo ""
        echo "âš ï¸  This setup requires administrator privileges:"
        echo "    - Linux: sudo access for system packages (you may be prompted for password)"
        echo "    - macOS: Homebrew must be installed first"
        echo ""
        echo "This will install:"
        echo "  â€¢ Go 1.25.3"
        echo "  â€¢ Node.js LTS"
        echo "  â€¢ Build tools (gcc, git, wget, etc.)"
        echo "  â€¢ Go dev tools (golangci-lint, air)"
        echo "  â€¢ Frontend dependencies and Playwright browsers"
        echo ""
        printf "Continue with setup? (y/N) "
        read REPLY
        case "$REPLY" in
          [Yy]|[Yy][Ee][Ss]) ;;
          *) echo "Setup cancelled."; exit 1 ;;
        esac
      - task: detect-and-install-deps
      - task: install-go-tools
      - task: setup-frontend-dev
      - task: check-tensorflow
      - task: verify-dev-setup
      - |
        echo ""
        echo "âœ… Development environment setup complete!"
        echo ""
        echo "âš ï¸  If Go was just installed, run: source ~/.profile"
        echo ""
        echo "Next steps:"
        echo "  1. Run 'task' to build the project"
        echo "  2. Run 'task dev_server' for development with hot reload"
        echo "  3. Run 'air realtime' for hot reload with realtime analysis"
        echo ""

  detect-and-install-deps:
    desc: Detect OS and install system dependencies
    internal: true
    cmds:
      - |
        echo "ðŸ” Detecting operating system..."

        # Use uname for reliable OS detection (OSTYPE is bash-specific and may be empty)
        DETECTED_OS="$(uname -s)"

        if [ "$DETECTED_OS" = "Linux" ]; then
          echo "ðŸ“¦ Installing dependencies for Linux (apt-based)..."

          # Check if running as root or with sudo
          if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
          else
            SUDO=""
          fi

          # Update package list
          $SUDO apt-get update

          # Install base development tools
          $SUDO apt-get install -y \
            build-essential \
            git \
            wget \
            curl \
            unzip \
            ca-certificates

          # Install Go if not present or version is too old
          REQUIRED_GO_VERSION="1.25"
          GO_VERSION="1.25.3"
          INSTALL_GO=false

          if ! command -v go >/dev/null 2>&1; then
            echo "ðŸ“¥ Go not found, installing Go ${GO_VERSION}..."
            INSTALL_GO=true
          else
            CURRENT_GO_VERSION=$(go version | awk '{print $3}' | sed 's/go//')
            CURRENT_GO_MINOR=$(echo "$CURRENT_GO_VERSION" | cut -d. -f1,2)

            case "$CURRENT_GO_MINOR" in
              ${REQUIRED_GO_VERSION}*)
                echo "âœ… Go ${CURRENT_GO_VERSION} is already installed (meets requirement)"
                ;;
              *)
                echo "âš ï¸  Go ${CURRENT_GO_VERSION} found, but Go ${REQUIRED_GO_VERSION}.x required"
                echo "   Current: ${CURRENT_GO_VERSION}"
                echo "   Required: ${REQUIRED_GO_VERSION}.x"
                echo ""
                printf "   Upgrade to Go ${GO_VERSION}? (y/N) "
                read REPLY
                case "$REPLY" in
                  [Yy]|[Yy][Ee][Ss]) INSTALL_GO=true ;;
                  *) echo "âš ï¸  Continuing with Go ${CURRENT_GO_VERSION} - you may encounter compatibility issues" ;;
                esac
                ;;
            esac
          fi

          if [ "$INSTALL_GO" = true ]; then
            echo "ðŸ“¥ Installing Go ${GO_VERSION}..."
            if ! wget "https://go.dev/dl/go${GO_VERSION}.linux-amd64.tar.gz"; then
              echo "âŒ Failed to download Go ${GO_VERSION}"
              echo "   Check your internet connection and try again"
              exit 1
            fi

            $SUDO rm -rf /usr/local/go
            if ! $SUDO tar -C /usr/local -xzf "go${GO_VERSION}.linux-amd64.tar.gz"; then
              echo "âŒ Failed to extract Go ${GO_VERSION}"
              rm -f "go${GO_VERSION}.linux-amd64.tar.gz"
              exit 1
            fi
            rm -f "go${GO_VERSION}.linux-amd64.tar.gz"

            # Add Go to PATH if not already there
            if ! grep -q "/usr/local/go/bin" ~/.profile 2>/dev/null; then
              echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.profile
              echo 'export PATH=$PATH:$HOME/go/bin' >> ~/.profile
              echo "âš ï¸  Please run 'source ~/.profile' or restart your shell"
            fi
            export PATH=$PATH:/usr/local/go/bin:$HOME/go/bin
            echo "âœ… Go ${GO_VERSION} installed successfully"
          fi

          # Install Node.js (LTS) if not present
          if ! command -v node >/dev/null 2>&1; then
            echo "ðŸ“¥ Installing Node.js LTS..."
            # Install latest LTS (currently 22.x, but will update automatically)
            # Add timeout for script download and execution
            if ! timeout 120 bash -c "curl -fsSL https://deb.nodesource.com/setup_lts.x | $SUDO -E bash -"; then
              echo "âŒ Failed to setup NodeSource repository"
              echo "   Check your internet connection and try again"
              exit 1
            fi
            if ! $SUDO apt-get install -y nodejs; then
              echo "âŒ Failed to install Node.js"
              exit 1
            fi
            INSTALLED_NODE=$(node --version)
            echo "âœ… Node.js ${INSTALLED_NODE} installed"
          else
            echo "âœ… Node.js $(node --version) is already installed"
          fi

          # Install cross-compilation toolchains (optional)
          if ! command -v aarch64-linux-gnu-gcc >/dev/null 2>&1; then
            echo ""
            echo "ðŸ”§ ARM64 cross-compilation tools (optional):"
            echo "   Allows building for ARM64/aarch64 from x86_64"
            echo "   Useful for building for Raspberry Pi, etc."
            echo ""
            printf "   Install ARM64 cross-compilation tools? (y/N) "
            read REPLY
            case "$REPLY" in
              [Yy]|[Yy][Ee][Ss])
                echo "ðŸ“¥ Installing ARM64 cross-compilation tools..."
                $SUDO apt-get install -y gcc-aarch64-linux-gnu
                echo "âœ… ARM64 cross-compilation tools installed"
                ;;
              *)
                echo "â­ï¸  Skipping ARM64 cross-compilation tools"
                ;;
            esac
          else
            echo "âœ… ARM64 cross-compilation tools already installed"
          fi

          # Install task if not present
          if ! command -v task >/dev/null 2>&1; then
            echo "ðŸ“¥ Installing Task (go-task)..."
            sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin
          fi

        elif [ "$DETECTED_OS" = "Darwin" ]; then
          echo "ðŸ“¦ Installing dependencies for macOS (homebrew)..."

          # Check if homebrew is installed
          if ! command -v brew >/dev/null 2>&1; then
            echo "âŒ Homebrew not found. Please install it first:"
            echo "   /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
            exit 1
          fi

          # Update homebrew
          brew update

          # Install base tools
          brew install git wget curl

          # Install Go with version checking
          REQUIRED_GO_VERSION="1.25"
          INSTALL_GO=false

          if ! command -v go >/dev/null 2>&1; then
            echo "ðŸ“¥ Go not found, installing..."
            INSTALL_GO=true
          else
            CURRENT_GO_VERSION=$(go version | awk '{print $3}' | sed 's/go//')
            CURRENT_GO_MINOR=$(echo "$CURRENT_GO_VERSION" | cut -d. -f1,2)

            case "$CURRENT_GO_MINOR" in
              ${REQUIRED_GO_VERSION}*)
                echo "âœ… Go ${CURRENT_GO_VERSION} is already installed (meets requirement)"
                ;;
              *)
                echo "âš ï¸  Go ${CURRENT_GO_VERSION} found, but Go ${REQUIRED_GO_VERSION}.x required"
                echo "   Current: ${CURRENT_GO_VERSION}"
                echo "   Required: ${REQUIRED_GO_VERSION}.x"
                echo ""
                printf "   Upgrade to Go ${REQUIRED_GO_VERSION}? (y/N) "
                read REPLY
                case "$REPLY" in
                  [Yy]|[Yy][Ee][Ss]) INSTALL_GO=true ;;
                  *) echo "âš ï¸  Continuing with Go ${CURRENT_GO_VERSION} - you may encounter compatibility issues" ;;
                esac
                ;;
            esac
          fi

          if [ "$INSTALL_GO" = true ]; then
            echo "ðŸ“¥ Installing Go ${REQUIRED_GO_VERSION}..."
            # Try versioned formula first, fallback to latest
            if brew install go@1.25 2>/dev/null; then
              echo "âœ… Go 1.25.x installed via go@1.25"
              # Link the versioned formula
              brew link go@1.25 || true
            else
              echo "âš ï¸  go@1.25 formula not available, installing latest Go"
              brew install go
              INSTALLED_VERSION=$(go version | awk '{print $3}' | sed 's/go//')
              echo "âœ… Go ${INSTALLED_VERSION} installed"
              case "$INSTALLED_VERSION" in
                ${REQUIRED_GO_VERSION}*) ;;
                *) echo "âš ï¸  Installed version may not match project requirements" ;;
              esac
            fi
          fi

          # Install Node.js LTS (current LTS, not locked to specific version)
          if ! command -v node >/dev/null 2>&1; then
            echo "ðŸ“¥ Installing Node.js LTS..."
            # Install latest LTS instead of locking to Node 22
            brew install node
            INSTALLED_NODE=$(node --version)
            echo "âœ… Node.js ${INSTALLED_NODE} installed"
          else
            echo "âœ… Node.js $(node --version) is already installed"
          fi

          # Install task
          if ! command -v task >/dev/null 2>&1; then
            echo "ðŸ“¥ Installing Task (go-task)..."
            brew install go-task
          fi

        else
          echo "âŒ Unsupported operating system: $DETECTED_OS"
          echo "This script supports Linux (apt-based) and macOS (homebrew)"
          exit 1
        fi

        echo "âœ… System dependencies installed"

  install-go-tools:
    desc: Install Go development tools
    internal: true
    cmds:
      - |
        echo "ðŸ”§ Installing Go development tools..."

        # Install golangci-lint
        if ! command -v golangci-lint >/dev/null 2>&1; then
          echo "ðŸ“¥ Installing golangci-lint..."
          # Add timeout for install script download and execution
          if ! timeout 120 bash -c "curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b \$(go env GOPATH)/bin"; then
            echo "âŒ Failed to install golangci-lint"
            echo "   Check your internet connection and try again"
            exit 1
          fi
        else
          echo "âœ… golangci-lint already installed"
        fi

        # Install air for hot reload (required for dev workflow)
        if ! command -v air >/dev/null 2>&1; then
          echo "ðŸ“¥ Installing air (hot reload)..."
          if ! go install github.com/air-verse/air@latest; then
            echo "âŒ Failed to install air"
            exit 1
          fi
        else
          echo "âœ… air already installed"
        fi

        echo "âœ… Go tools installed"

  setup-frontend-dev:
    desc: Setup frontend development environment
    internal: true
    dir: frontend
    cmds:
      - |
        echo "ðŸŽ¨ Setting up frontend development environment..."

        # Install frontend dependencies
        if [ ! -d "node_modules" ]; then
          echo "ðŸ“¥ Installing frontend dependencies..."
          if ! npm install; then
            echo "âŒ Failed to install frontend dependencies"
            echo "   Check your network connection and try again"
            exit 1
          fi
        else
          echo "âœ… Frontend dependencies already installed"
        fi

        # Install Playwright browsers for E2E testing
        echo "ðŸ“¥ Installing Playwright browsers..."
        if ! npx playwright install --with-deps chromium; then
          echo "âŒ Failed to install Playwright browsers"
          echo "   You can install them later with: cd frontend && npx playwright install --with-deps chromium"
          echo "âš ï¸  Continuing setup without Playwright browsers"
        else
          echo "âœ… Playwright browsers installed"
        fi

        # Return to root directory to initialize Husky
        cd ..

        # Initialize Husky for git hooks (pre-commit checks)
        echo "ðŸª Setting up git hooks with Husky..."
        if [ -d ".git" ]; then
          cd frontend
          if ! npm run prepare; then
            echo "âš ï¸  Failed to initialize Husky"
            echo "   Git hooks won't be active, but you can initialize later with: cd frontend && npm run prepare"
          else
            echo "âœ… Git hooks initialized"
            echo "   Pre-commit hook will run golangci-lint and frontend linting automatically"
          fi
          cd ..
        else
          echo "âš ï¸  Not a git repository, skipping Husky setup"
        fi

        echo "âœ… Frontend setup complete"

  verify-dev-setup:
    desc: Verify development environment setup
    internal: true
    cmds:
      - |
        echo ""
        echo "ðŸ” Verifying development environment..."
        echo ""

        # Check Go with version validation
        REQUIRED_GO_VERSION="1.25"
        if command -v go >/dev/null 2>&1; then
          CURRENT_GO_VERSION=$(go version | awk '{print $3}' | sed 's/go//')
          CURRENT_GO_MINOR=$(echo "$CURRENT_GO_VERSION" | cut -d. -f1,2)

          case "$CURRENT_GO_MINOR" in
            ${REQUIRED_GO_VERSION}*)
              echo "âœ… Go: ${CURRENT_GO_VERSION} (meets ${REQUIRED_GO_VERSION}.x requirement)"
              ;;
            *)
              echo "âŒ Go: ${CURRENT_GO_VERSION} found, but ${REQUIRED_GO_VERSION}.x required"
              echo "   Current version does not match project requirements"
              echo "   Run 'task setup-dev' to install the correct version"
              exit 1
              ;;
          esac
        else
          echo "âŒ Go: not found"
          echo "   Run 'task setup-dev' to install Go"
          exit 1
        fi

        # Check Node.js
        if command -v node >/dev/null 2>&1; then
          echo "âœ… Node.js: $(node --version)"
        else
          echo "âŒ Node.js: not found"
          exit 1
        fi

        # Check npm
        if command -v npm >/dev/null 2>&1; then
          echo "âœ… npm: $(npm --version)"
        else
          echo "âŒ npm: not found"
          exit 1
        fi

        # Check golangci-lint (required for pre-commit linting)
        if command -v golangci-lint >/dev/null 2>&1; then
          echo "âœ… golangci-lint: $(golangci-lint --version | head -n1)"
        else
          echo "âŒ golangci-lint: not found (required for development)"
          exit 1
        fi

        # Check air (required for hot reload development)
        if command -v air >/dev/null 2>&1; then
          echo "âœ… air: installed"
        else
          echo "âŒ air: not found (required for 'task dev_server' and 'air' commands)"
          exit 1
        fi

        # Check task
        if command -v task >/dev/null 2>&1; then
          echo "âœ… task: $(task --version)"
        else
          echo "âŒ task: not found"
          exit 1
        fi

        # Check git
        if command -v git >/dev/null 2>&1; then
          echo "âœ… git: $(git --version)"
        else
          echo "âŒ git: not found"
          exit 1
        fi

        # Check frontend dependencies
        if [ -d "frontend/node_modules" ]; then
          echo "âœ… Frontend dependencies: installed"
        else
          echo "âŒ Frontend dependencies: not installed"
          exit 1
        fi

        # Check git hooks (Husky pre-commit)
        if [ -f ".git/hooks/pre-commit" ]; then
          echo "âœ… Git hooks: configured (pre-commit checks active)"
        else
          echo "âš ï¸  Git hooks: not initialized"
          echo "   Run: cd frontend && npm run prepare"
        fi

        # Check Playwright (optional for E2E tests)
        cd frontend
        if npx playwright --version >/dev/null 2>&1; then
          PLAYWRIGHT_VERSION=$(npx playwright --version)
          echo "âœ… Playwright: ${PLAYWRIGHT_VERSION}"
        else
          echo "âš ï¸  Playwright: not installed (optional for E2E tests)"
          echo "   Install with: cd frontend && npx playwright install --with-deps chromium"
        fi
        cd ..

        echo ""
        echo "âœ… All required tools are installed"

  check-tools:
    cmds:
      - |
        for cmd in go unzip git wget; do
          if ! command -v $cmd >/dev/null; then
            echo "$cmd not found. Please install it."
            exit 1
          fi
        done

  check-tensorflow:
    cmds:
      - |
        if [ ! -f "$HOME/src/tensorflow/tensorflow/lite/c/c_api.h" ]; then
          echo "TensorFlow Lite C API header not found. Cloning TensorFlow source..."
          mkdir -vp $HOME/src
          echo "Cloning TensorFlow source..."
          git clone --branch {{.TFLITE_VERSION}} --filter=blob:none --depth 1 https://github.com/tensorflow/tensorflow.git $HOME/src/tensorflow
          echo "Setting up sparse checkout..."
          git -C $HOME/src/tensorflow config core.sparseCheckout true
          echo "**/*.h" >> $HOME/src/tensorflow/.git/info/sparse-checkout
          echo "Checking out TensorFlow source..."
          git -C $HOME/src/tensorflow checkout
        else
          echo "TensorFlow headers already exist at version {{.TFLITE_VERSION}}"
        fi

  dev_server:
    cmds:
      - air realtime

  # Frontend build tasks
  frontend-install:
    desc: Install frontend dependencies
    dir: frontend
    cmds:
      - npm install
    sources:
      - package.json
      - package-lock.json
    generates:
      - node_modules/.package-lock.json

  frontend-typecheck:
    desc: Run TypeScript type checking on frontend
    dir: frontend
    deps: [frontend-install]
    cmds:
      - npm run typecheck
    sources:
      - src/**/*
      - tsconfig.json
      - package.json

  frontend-build:
    desc: Build frontend for production with strict type checking
    dir: frontend
    deps: [frontend-install, frontend-typecheck]
    cmds:
      - npm run build
    sources:
      - src/**/*
      - index.html
      - vite.config.js
      - package.json
    generates:
      - dist/**/*

  frontend-dev:
    desc: Start Vite dev server with HMR (access via localhost:5173)
    dir: frontend
    deps: [frontend-install]
    cmds:
      - npm run dev

  frontend-watch:
    desc: Build frontend in watch mode (auto-rebuild on changes)
    dir: frontend
    deps: [frontend-install]
    cmds:
      - |
        echo "ðŸ”§ Starting frontend watch mode..."
        echo "   Files will be rebuilt automatically when changed"
        echo "   The Go server will serve these files from disk"
        echo ""
      - npm run build -- --watch

  dev:
    desc: Show instructions for frontend development workflow
    cmds:
      - |
        echo ""
        echo "ðŸš€ BirdNET-Go Frontend Development Workflow"
        echo ""
        echo "The Go server automatically detects and serves frontend files from disk"
        echo "when frontend/dist/ exists, enabling fast frontend iteration without"
        echo "rebuilding the Go binary."
        echo ""
        echo "Option 1: Watch Mode (recommended for most development)"
        echo "==========================================================="
        echo "Terminal 1: task frontend-watch    # Auto-rebuilds on file changes"
        echo "Terminal 2: ./bin/birdnet-go realtime  # Or: air realtime (for Go changes)"
        echo "Access: http://localhost:8080"
        echo ""
        echo "Option 2: Vite Dev Server (for HMR - instant updates)"
        echo "==========================================================="
        echo "Terminal 1: task frontend-dev      # Vite dev server with HMR"
        echo "Terminal 2: ./bin/birdnet-go realtime  # Backend for API calls"
        echo "Access: http://localhost:5173      # Note: different port!"
        echo ""
        echo "Option 3: Backend-only development (Go changes)"
        echo "==========================================================="
        echo "Terminal 1: task frontend-watch    # Keep frontend fresh"
        echo "Terminal 2: air realtime           # Auto-rebuilds Go on changes"
        echo "Access: http://localhost:8080"
        echo ""
        echo "Quick Start:"
        echo "  task frontend-watch  # In one terminal"
        echo "  air realtime         # In another terminal"
        echo ""

  frontend-lint:
    desc: Lint frontend code
    dir: frontend
    deps: [frontend-install]
    cmds:
      - npm run check:all

  frontend-lint-fix:
    desc: Fix frontend linting issues automatically
    dir: frontend
    deps: [frontend-install]
    cmds:
      - npm run format
      - npm run lint -- --fix
      - npm run ast:fix

  frontend-ast-fix:
    desc: Auto-fix ast-grep detected issues
    dir: frontend
    deps: [frontend-install]
    cmds:
      - npm run ast:fix

  frontend-test:
    desc: Run frontend tests
    dir: frontend
    deps: [frontend-install]
    cmds:
      - npm run test -- --run

  # Integration Testing Tasks
  integration-backend:
    desc: Start backend for integration testing (air with hot reload)
    cmds:
      - air realtime

  integration-test:
    desc: Run frontend integration tests (backend must be running)
    dir: frontend
    deps: [frontend-install]
    cmds:
      - |
        if ! curl -s http://localhost:8080/api/v2/health > /dev/null 2>&1; then
          echo "âš ï¸  Backend not running at localhost:8080"
          echo "   Start it with: task integration-backend"
          echo "   Or use: task integration-test-auto (starts backend automatically)"
          echo ""
          echo "Running tests anyway (they will be skipped if backend unavailable)..."
        fi
      - npm run test:integration -- --run

  integration-test-auto:
    desc: Run integration tests with automatic backend management
    dir: frontend
    deps: [frontend-install]
    cmds:
      - |
        echo "ðŸ§ª Running integration tests with auto-managed backend..."
        echo "   Backend will be started automatically by Vitest global setup"
      - npm run test:integration:auto -- --run

  frontend-test-coverage:
    desc: Run frontend tests with coverage
    dir: frontend
    deps: [frontend-install]
    cmds:
      - npm run test:coverage

  frontend-quality:
    desc: Run comprehensive frontend quality checks and auto-fix issues
    dir: frontend
    deps: [frontend-install]
    cmds:
      - npm run format
      - npm run lint -- --fix
      - npm run ast:fix
      - npm run check:all
      - npm run test:ci
      - npm run audit:security
      - npm run analyze:circular
      - npm run build
      - npm run analyze:bundle:size

  # Format all markdown files with prettier
  format-md:
    desc: Format all markdown files in the project with prettier
    dir: frontend
    deps: [frontend-install]
    cmds:
      - npx prettier --write "../**/*.md"

  # E2E Testing Tasks
  e2e-install:
    desc: Install E2E testing dependencies
    dir: frontend
    cmds:
      - npm install -D @playwright/test playwright @axe-core/playwright
      - npx playwright install

  e2e-test:
    desc: Run end-to-end tests
    dir: frontend
    deps: [frontend-build, e2e-install]
    cmds:
      - npx playwright test

  e2e-test-headed:
    desc: Run E2E tests in headed mode for debugging
    dir: frontend
    cmds:
      - npx playwright test --headed

  e2e-test-ui:
    desc: Run E2E tests with Playwright UI mode
    dir: frontend
    cmds:
      - npx playwright test --ui

  e2e-test-mobile:
    desc: Run E2E tests on mobile devices only
    dir: frontend
    cmds:
      - npx playwright test --grep="mobile|responsive"

  e2e-test-performance:
    desc: Run performance-focused E2E tests
    dir: frontend
    cmds:
      - npx playwright test --grep="performance"

  e2e-report:
    desc: Open E2E test report
    dir: frontend
    cmds:
      - npx playwright show-report

  clean:
    cmds:
      - go clean
      - rm -rf {{.BINARY_DIR}}/* tflite_c *.tar.gz *.zip
      - rm -f {{.AVICOMMONS_DATA_DIR}}/{{.AVICOMMONS_JSON_FILE}}
      - rm -rf frontend/dist frontend/node_modules

  # Non-embedded builds (without embedded models - smaller binary size)
  noembed:
    desc: Build for native platform without embedded models
    deps: [noembed-native-target]

  noembed-native-target:
    cmds:
      - |
        if [ "{{.OS}}" = "unsupported" ] || [ "{{.ARCH}}" = "unsupported" ]; then
          echo "Error: Unsupported platform combination: OS={{.OS}}, ARCH={{.ARCH}}"
          exit 1
        fi
      - task: "noembed_{{OS}}_{{ARCH}}"
    vars:
      OS:
        sh: |
          case "{{.UNAME_S}}" in
            Linux) echo "linux";;
            Darwin) echo "darwin";;
            *) echo "unsupported";;
          esac
      ARCH:
        sh: |
          case "{{.UNAME_M}}" in
            x86_64) echo "amd64";;
            aarch64|arm64) echo "arm64";;
            *) echo "unsupported";;
          esac

  linux_amd64:
    deps: [check-tools, check-tensorflow, download-avicommons-data, frontend-build]
    vars:
      TFLITE_LIB_DIR: '{{.DOCKER_LIB_DIR | default .SYSTEM_LIB_DIR_AMD64}}'
      TFLITE_LIB_ARCH: linux_amd64.tar.gz
      TARGET: linux_amd64
    cmds:
      - task: download-tflite
        vars: {TFLITE_LIB_DIR: '{{.TFLITE_LIB_DIR}}', TFLITE_LIB_ARCH: '{{.TFLITE_LIB_ARCH}}', TARGET: '{{.TARGET}}'}
      - |
        mkdir -p {{.TFLITE_LIB_DIR}}
        GOOS=linux GOARCH=amd64 {{.CGO_FLAGS}} \
        CGO_LDFLAGS="-L{{.TFLITE_LIB_DIR}} -ltensorflowlite_c" \
        go build -trimpath {{.BUILD_FLAGS}} -o {{.BINARY_DIR}}/{{.BINARY_NAME}}

  linux_arm64:
    deps: [check-tools, check-tensorflow, download-avicommons-data, frontend-build]
    vars:
      TFLITE_LIB_DIR: '{{.DOCKER_LIB_DIR | default .SYSTEM_LIB_DIR_ARM64}}'
      TFLITE_LIB_ARCH: linux_arm64.tar.gz
      TARGET: linux_arm64
    cmds:
      - task: download-tflite
        vars: {TFLITE_LIB_DIR: '{{.TFLITE_LIB_DIR}}', TFLITE_LIB_ARCH: '{{.TFLITE_LIB_ARCH}}', TARGET: '{{.TARGET}}'}
      - |
        mkdir -p {{.TFLITE_LIB_DIR}}
        if [ "$(uname -m)" != "aarch64" ]; then
          export CC=aarch64-linux-gnu-gcc
        fi
        GOOS=linux GOARCH=arm64 {{.CGO_FLAGS}} \
        CGO_LDFLAGS="-L{{.TFLITE_LIB_DIR}} -ltensorflowlite_c" \
        go build -trimpath {{.BUILD_FLAGS}} -o {{.BINARY_DIR}}/{{.BINARY_NAME}}

  windows_amd64:
    deps: [check-tools, check-tensorflow, download-avicommons-data, frontend-build]
    vars:
      TFLITE_LIB_DIR: /usr/x86_64-w64-mingw32/lib
      TFLITE_LIB_ARCH: windows_amd64.zip
      TARGET: windows_amd64
    cmds:
      - task: download-tflite
        vars: {TFLITE_LIB_DIR: '{{.TFLITE_LIB_DIR}}', TFLITE_LIB_ARCH: '{{.TFLITE_LIB_ARCH}}', TARGET: '{{.TARGET}}'}
      - |
        GOOS=windows GOARCH=amd64 {{.CGO_FLAGS}} \
        CC=x86_64-w64-mingw32-gcc \
        CGO_LDFLAGS="-L{{.TFLITE_LIB_DIR}} -ltensorflowlite_c" \
        go build -trimpath {{.BUILD_FLAGS}} -o {{.BINARY_DIR}}/{{.BINARY_NAME}}.exe

  darwin_amd64:
    deps: [check-tools, check-tensorflow, download-avicommons-data, frontend-build]
    vars:
      TFLITE_LIB_DIR: /usr/local/lib
      TFLITE_LIB_ARCH: darwin_amd64.tar.gz
      TARGET: darwin_amd64
    cmds:
      - task: download-tflite
        vars: {TFLITE_LIB_DIR: '{{.TFLITE_LIB_DIR}}', TFLITE_LIB_ARCH: '{{.TFLITE_LIB_ARCH}}', TARGET: '{{.TARGET}}'}
      - |
        GOOS=darwin GOARCH=amd64 {{.CGO_FLAGS}} \
        CGO_LDFLAGS="-L{{.TFLITE_LIB_DIR}} -ltensorflowlite_c" \
        go build -trimpath {{.BUILD_FLAGS}} -o {{.BINARY_DIR}}/{{.BINARY_NAME}}

  darwin_arm64:
    deps: [check-tools, check-tensorflow, download-avicommons-data, frontend-build]
    vars:
      TFLITE_LIB_DIR: /opt/homebrew/lib
      TFLITE_LIB_ARCH: darwin_arm64.tar.gz
      TARGET: darwin_arm64
    cmds:
      - task: download-tflite
        vars: {TFLITE_LIB_DIR: '{{.TFLITE_LIB_DIR}}', TFLITE_LIB_ARCH: '{{.TFLITE_LIB_ARCH}}', TARGET: '{{.TARGET}}'}
      - |
        GOOS=darwin GOARCH=arm64 {{.CGO_FLAGS}} \
        CGO_LDFLAGS="-L{{.TFLITE_LIB_DIR}} -ltensorflowlite_c" \
        go build -trimpath {{.BUILD_FLAGS}} -o {{.BINARY_DIR}}/{{.BINARY_NAME}}

  download-tflite:
    internal: true
    vars:
      LIB_FILENAME:
        sh: |
          case "{{.TARGET}}" in
            windows_amd64) echo "tensorflowlite_c-${TFLITE_VERSION#v}.dll";;
            linux*) echo "libtensorflowlite_c.so.${TFLITE_VERSION#v}";;
            darwin*) echo "libtensorflowlite_c.${TFLITE_VERSION#v}.dylib";;
          esac
    cmds:
      - |
        if [ ! -f "{{.TFLITE_LIB_DIR}}/{{.LIB_FILENAME}}" ]; then
          echo "TensorFlow Lite C library not found. Downloading..."
          wget -q "https://github.com/tphakala/tflite_c/releases/download/{{.TFLITE_VERSION}}/tflite_c_{{.TFLITE_VERSION}}_{{.TFLITE_LIB_ARCH}}" -P ./
          
          # Only create directory if it doesn't exist
          if [ ! -d "{{.TFLITE_LIB_DIR}}" ]; then
            if [ -w "$(dirname "{{.TFLITE_LIB_DIR}}")" ] 2>/dev/null; then
              mkdir -p "{{.TFLITE_LIB_DIR}}"
            else
              sudo mkdir -p "{{.TFLITE_LIB_DIR}}"
            fi
          fi
          
          case "{{.TFLITE_LIB_ARCH}}" in
            *.zip)
              unzip -o "tflite_c_{{.TFLITE_VERSION}}_{{.TFLITE_LIB_ARCH}}"
              if [ -w "{{.TFLITE_LIB_DIR}}" ]; then
                mv "{{.LIB_FILENAME}}" "{{.TFLITE_LIB_DIR}}/"
              else
                sudo mv "{{.LIB_FILENAME}}" "{{.TFLITE_LIB_DIR}}/"
              fi
              ;;
            *)
              tar -xzf "tflite_c_{{.TFLITE_VERSION}}_{{.TFLITE_LIB_ARCH}}"
              if [ -w "{{.TFLITE_LIB_DIR}}" ]; then
                mv "{{.LIB_FILENAME}}" "{{.TFLITE_LIB_DIR}}/"
              else
                sudo mv "{{.LIB_FILENAME}}" "{{.TFLITE_LIB_DIR}}/"
              fi
              ;;
          esac

          rm -f "tflite_c_{{.TFLITE_VERSION}}_{{.TFLITE_LIB_ARCH}}"
        fi
      - task: ensure-tflite-symlinks
        vars: {LIB_DIR: '{{.TFLITE_LIB_DIR}}', LIB_FILENAME: '{{.LIB_FILENAME}}'}

  # Internal task for building noembed binaries across platforms
  noembed_build:
    internal: true
    deps: [check-tools, check-tensorflow, download-avicommons-data, frontend-build]
    cmds:
      - task: download-tflite
        vars: 
          TFLITE_LIB_DIR: '{{.TFLITE_LIB_DIR}}'
          TFLITE_LIB_ARCH: '{{.TFLITE_LIB_ARCH}}'
          TARGET: '{{.TARGET}}'
      - mkdir -p {{.BINARY_DIR}}
      - |
        {{if .CROSS_COMPILE_CHECK}}
        if [ "$(uname -m)" != "{{.CROSS_COMPILE_CHECK}}" ]; then
          export CC={{.CC}}
        fi
        {{else if .CC}}
        export CC={{.CC}}
        {{end}}
        GOOS={{.GOOS}} GOARCH={{.GOARCH}} {{.CGO_FLAGS}} \
          CGO_LDFLAGS="-L{{.TFLITE_LIB_DIR}} -ltensorflowlite_c" \
          go build -trimpath -tags noembed {{.BUILD_FLAGS}} -o {{.BINARY_DIR}}/{{.BINARY_NAME}}{{.BINARY_SUFFIX}}
        echo "Built non-embedded binary: {{.BINARY_DIR}}/{{.BINARY_NAME}}{{.BINARY_SUFFIX}}"
        echo "Note: This binary requires external model files to run"

  noembed_linux_amd64:
    desc: Build Linux AMD64 without embedded models
    cmds:
      - task: noembed_build
        vars:
          TFLITE_LIB_DIR: '{{.DOCKER_LIB_DIR | default .SYSTEM_LIB_DIR_AMD64}}'
          TFLITE_LIB_ARCH: linux_amd64.tar.gz
          TARGET: linux_amd64
          GOOS: linux
          GOARCH: amd64
          BINARY_SUFFIX: ''

  noembed_linux_arm64:
    desc: Build Linux ARM64 without embedded models
    cmds:
      - task: noembed_build
        vars:
          TFLITE_LIB_DIR: '{{.DOCKER_LIB_DIR | default .SYSTEM_LIB_DIR_ARM64}}'
          TFLITE_LIB_ARCH: linux_arm64.tar.gz
          TARGET: linux_arm64
          GOOS: linux
          GOARCH: arm64
          CROSS_COMPILE_CHECK: 'aarch64'
          CC: 'aarch64-linux-gnu-gcc'
          BINARY_SUFFIX: ''

  noembed_windows_amd64:
    desc: Build Windows AMD64 without embedded models
    cmds:
      - task: noembed_build
        vars:
          TFLITE_LIB_DIR: /usr/x86_64-w64-mingw32/lib
          TFLITE_LIB_ARCH: windows_amd64.zip
          TARGET: windows_amd64
          GOOS: windows
          GOARCH: amd64
          CC: x86_64-w64-mingw32-gcc
          BINARY_SUFFIX: '.exe'

  noembed_darwin_amd64:
    desc: Build Darwin AMD64 without embedded models
    cmds:
      - task: noembed_build
        vars:
          TFLITE_LIB_DIR: /usr/local/lib
          TFLITE_LIB_ARCH: darwin_amd64.tar.gz
          TARGET: darwin_amd64
          GOOS: darwin
          GOARCH: amd64
          BINARY_SUFFIX: ''

  noembed_darwin_arm64:
    desc: Build Darwin ARM64 without embedded models
    cmds:
      - task: noembed_build
        vars:
          TFLITE_LIB_DIR: /opt/homebrew/lib
          TFLITE_LIB_ARCH: darwin_arm64.tar.gz
          TARGET: darwin_arm64
          GOOS: darwin
          GOARCH: arm64
          BINARY_SUFFIX: ''

  ensure-tflite-symlinks:
    internal: true
    cmds:
      - |
        # Only create directory if it doesn't exist
        if [ ! -d "{{.LIB_DIR}}" ]; then
          if [ -w "$(dirname "{{.LIB_DIR}}")" ] 2>/dev/null; then
            mkdir -p "{{.LIB_DIR}}"
          else
            sudo mkdir -p "{{.LIB_DIR}}"
          fi
        fi
      - |
        case "{{.LIB_FILENAME}}" in
          *.dll)
            if [ ! -f "{{.LIB_DIR}}/tensorflowlite_c.dll" ]; then
              if [ -w "{{.LIB_DIR}}" ]; then
                ln -sf "{{.LIB_DIR}}/{{.LIB_FILENAME}}" "{{.LIB_DIR}}/tensorflowlite_c.dll"
              else
                sudo ln -sf "{{.LIB_DIR}}/{{.LIB_FILENAME}}" "{{.LIB_DIR}}/tensorflowlite_c.dll"
              fi
            fi
            ;;
          *)
            if [ "{{.UNAME_S}}" = "Linux" ] && [ ! -f "{{.LIB_DIR}}/libtensorflowlite_c.so" ]; then
              if [ -w "{{.LIB_DIR}}" ]; then
                cd {{.LIB_DIR}} && \
                ln -sf {{.LIB_FILENAME}} libtensorflowlite_c.so.2 && \
                ln -sf libtensorflowlite_c.so.2 libtensorflowlite_c.so
              else
                cd {{.LIB_DIR}} && \
                sudo ln -sf {{.LIB_FILENAME}} libtensorflowlite_c.so.2 && \
                sudo ln -sf libtensorflowlite_c.so.2 libtensorflowlite_c.so
              fi
            elif [ "{{.UNAME_S}}" = "Darwin" ] && [ ! -f "{{.LIB_DIR}}/libtensorflowlite_c.dylib" ]; then
              cd {{.LIB_DIR}} && \
              ln -sf {{.LIB_FILENAME}} libtensorflowlite_c.dylib
            fi
            ;;
        esac
      
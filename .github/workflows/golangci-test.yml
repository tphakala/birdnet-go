name: golangci-test
on:
  push:
    branches:
      - main
    paths:
      - '**/*.go'
      - 'go.mod'
      - 'go.sum'
      - '.golangci.yml'
  pull_request:
    paths:
      - '**/*.go'
      - 'go.mod'
      - 'go.sum'
      - '.golangci.yml'

jobs:
  golangci:
    uses: ./.github/workflows/golangci-lint.yml

  unit-tests:
    needs: golangci
    runs-on: ubuntu-24.04
    services:
      mosquitto:
        image: eclipse-mosquitto:1.6
        ports:
          - 1883:1883
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-go@v6
        with:
          go-version: '1.25.1'
          cache: true
      - run: go version

      - name: Install Task
        uses: arduino/setup-task@v2
        with:
          version: 3.x
          repo-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Cache TensorFlow headers
        uses: actions/cache@v5
        with:
          path: ~/src/tensorflow
          key: ${{ runner.os }}-tensorflow-v2.17.1

      - name: Install dependencies
        run: task check-tensorflow

      - name: Install FFmpeg and test dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg procps

      - name: Cache TensorFlow Lite library
        id: cache-tflite
        uses: actions/cache@v5
        with:
          path: /usr/lib/libtensorflowlite_c.so*
          key: ${{ runner.os }}-tflite-v2.17.1

      - name: Download tflite_c
        if: steps.cache-tflite.outputs.cache-hit != 'true'
        run: |
          TFLITE_VERSION=v2.17.1
          wget -q https://github.com/tphakala/tflite_c/releases/download/${TFLITE_VERSION}/tflite_c_${TFLITE_VERSION}_linux_amd64.tar.gz -P ./
          tar -xzf tflite_c_${TFLITE_VERSION}_linux_amd64.tar.gz -C .
          sudo mv libtensorflowlite_c.so.2.17.1 /usr/lib/libtensorflowlite_c.so
          rm -f tflite_c_${TFLITE_VERSION}_linux_amd64.tar.gz

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '24'
          
      - name: Build Frontend
        run: |
          cd frontend
          npm install
          npm run build

      - name: Set environment variables for CGO
        run: |
          echo "CGO_ENABLED=1" >> $GITHUB_ENV
          echo "CGO_CFLAGS=-I $HOME/src/tensorflow" >> $GITHUB_ENV

      - name: Cache Go tools
        uses: actions/cache@v5
        with:
          path: ~/go/bin
          key: ${{ runner.os }}-go-tools-gotestfmt-v2

      - name: Set up gotestfmt
        run: |
          if ! command -v gotestfmt &> /dev/null; then
            go install github.com/gotesttools/gotestfmt/v2/cmd/gotestfmt@latest
          fi

      - name: Wait for Mosquitto
        run: |
          echo "Waiting for Mosquitto to be ready..."
          for i in {1..30}; do
            if nc -zv localhost 1883 2>/dev/null; then
              echo "Mosquitto is ready!"
              break
            fi
            echo "Attempt $i: Mosquitto not ready yet, waiting..."
            sleep 1
          done
          # Final check
          nc -zv localhost 1883 || { echo "Mosquitto failed to start"; exit 1; }

      - name: Run unit tests
        env:
          CI: true
          MQTT_TEST_BROKER: tcp://localhost:1883
        run: |
          set -euo pipefail

          # Run tests with JSON output
          # Note: We must capture PIPESTATUS immediately after the pipeline
          # gotestfmt may return non-zero even when tests pass, so we only check go test's exit code
          go test -json -v -short -timeout 120s ./... 2>&1 | tee /tmp/gotest.log | gotestfmt -ci github; TEST_EXIT_CODE=${PIPESTATUS[0]}

          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "::error title=Test Failure::Unit tests failed - see job summary for details"

            # Create initial summary
            echo "## :x: Test Run Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Exit code: $TEST_EXIT_CODE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Quick preview of failures - parse JSON to extract test names
            echo "### Quick Preview of Failures" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            grep '"Action":"fail"' /tmp/gotest.log | jq -r 'select(.Test) | (.Package + " " + .Test)' | head -20 >> $GITHUB_STEP_SUMMARY 2>&1 || echo "Failed to parse test failures" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ‘‡ See 'Generate test failure report' step below for detailed analysis" >> $GITHUB_STEP_SUMMARY

            exit $TEST_EXIT_CODE
          fi

          echo "## :white_check_mark: All Tests Passed" >> $GITHUB_STEP_SUMMARY
        timeout-minutes: 5

      - name: Cleanup any remaining processes
        if: always()
        run: |
          # Kill any remaining test processes to prevent resource leaks
          pkill -f "test://" || true
          pkill -f "sleep.*test" || true
          pkill -f "sh.*-c.*sleep" || true

      - name: Generate test failure report
        if: failure()
        run: |
          echo "# Test Failure Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Count failures from JSON (count test-level failures, not package-level)
          FAIL_COUNT=$(grep '"Action":"fail"' /tmp/gotest.log | jq -s '[.[] | select(.Test)] | length' 2>/dev/null || echo "0")
          echo "**Total Failed Tests: $FAIL_COUNT**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Extract failed test details with error messages from JSON
          echo "## Failed Test Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get list of failed tests
          FAILED_TESTS=$(grep '"Action":"fail"' /tmp/gotest.log | jq -r 'select(.Test) | (.Package + "|" + .Test)' 2>/dev/null | sort -u)

          if [ -n "$FAILED_TESTS" ]; then
            while IFS='|' read -r pkg test; do
              echo "### âŒ \`$test\`" >> $GITHUB_STEP_SUMMARY
              echo "**Package:** \`$pkg\`" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              # Extract all output for this specific test from JSON, filtering out test framework lines
              grep "\"Test\":\"$test\"" /tmp/gotest.log | jq -r 'select(.Action == "output") | .Output' 2>/dev/null | grep -v "^===" | grep -v "^---" >> $GITHUB_STEP_SUMMARY || echo "No error details found" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            done <<< "$FAILED_TESTS"
          else
            echo "No test failures found in JSON output" >> $GITHUB_STEP_SUMMARY
          fi

          # Extract unique failing packages
          echo "## Affected Packages" >> $GITHUB_STEP_SUMMARY
          grep '"Action":"fail"' /tmp/gotest.log | jq -r 'select(.Package) | .Package' 2>/dev/null | sort -u >> $GITHUB_STEP_SUMMARY || echo "No packages identified" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“¥ Download the full test log artifact for complete details" >> $GITHUB_STEP_SUMMARY

      - name: Upload test log
        uses: actions/upload-artifact@v6
        if: always()
        with:
          name: test-log
          path: /tmp/gotest.log
          if-no-files-found: error

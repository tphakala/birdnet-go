// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	datastore "github.com/tphakala/birdnet-go/internal/datastore"
	detection "github.com/tphakala/birdnet-go/internal/detection"

	mock "github.com/stretchr/testify/mock"
)

// MockDetectionRepository is an autogenerated mock type for the DetectionRepository type
type MockDetectionRepository struct {
	mock.Mock
}

type MockDetectionRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockDetectionRepository) EXPECT() *MockDetectionRepository_Expecter {
	return &MockDetectionRepository_Expecter{mock: &_m.Mock}
}

// AddComment provides a mock function with given fields: ctx, id, comment
func (_m *MockDetectionRepository) AddComment(ctx context.Context, id string, comment string) error {
	ret := _m.Called(ctx, id, comment)

	if len(ret) == 0 {
		panic("no return value specified for AddComment")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, id, comment)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDetectionRepository_AddComment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddComment'
type MockDetectionRepository_AddComment_Call struct {
	*mock.Call
}

// AddComment is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - comment string
func (_e *MockDetectionRepository_Expecter) AddComment(ctx interface{}, id interface{}, comment interface{}) *MockDetectionRepository_AddComment_Call {
	return &MockDetectionRepository_AddComment_Call{Call: _e.mock.On("AddComment", ctx, id, comment)}
}

func (_c *MockDetectionRepository_AddComment_Call) Run(run func(ctx context.Context, id string, comment string)) *MockDetectionRepository_AddComment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockDetectionRepository_AddComment_Call) Return(_a0 error) *MockDetectionRepository_AddComment_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDetectionRepository_AddComment_Call) RunAndReturn(run func(context.Context, string, string) error) *MockDetectionRepository_AddComment_Call {
	_c.Call.Return(run)
	return _c
}

// CountAll provides a mock function with given fields: ctx
func (_m *MockDetectionRepository) CountAll(ctx context.Context) (int64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountAll")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDetectionRepository_CountAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountAll'
type MockDetectionRepository_CountAll_Call struct {
	*mock.Call
}

// CountAll is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDetectionRepository_Expecter) CountAll(ctx interface{}) *MockDetectionRepository_CountAll_Call {
	return &MockDetectionRepository_CountAll_Call{Call: _e.mock.On("CountAll", ctx)}
}

func (_c *MockDetectionRepository_CountAll_Call) Run(run func(ctx context.Context)) *MockDetectionRepository_CountAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDetectionRepository_CountAll_Call) Return(_a0 int64, _a1 error) *MockDetectionRepository_CountAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDetectionRepository_CountAll_Call) RunAndReturn(run func(context.Context) (int64, error)) *MockDetectionRepository_CountAll_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, id
func (_m *MockDetectionRepository) Delete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDetectionRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockDetectionRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockDetectionRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockDetectionRepository_Delete_Call {
	return &MockDetectionRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockDetectionRepository_Delete_Call) Run(run func(ctx context.Context, id string)) *MockDetectionRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDetectionRepository_Delete_Call) Return(_a0 error) *MockDetectionRepository_Delete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDetectionRepository_Delete_Call) RunAndReturn(run func(context.Context, string) error) *MockDetectionRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteComment provides a mock function with given fields: ctx, commentID
func (_m *MockDetectionRepository) DeleteComment(ctx context.Context, commentID uint) error {
	ret := _m.Called(ctx, commentID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteComment")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint) error); ok {
		r0 = rf(ctx, commentID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDetectionRepository_DeleteComment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteComment'
type MockDetectionRepository_DeleteComment_Call struct {
	*mock.Call
}

// DeleteComment is a helper method to define mock.On call
//   - ctx context.Context
//   - commentID uint
func (_e *MockDetectionRepository_Expecter) DeleteComment(ctx interface{}, commentID interface{}) *MockDetectionRepository_DeleteComment_Call {
	return &MockDetectionRepository_DeleteComment_Call{Call: _e.mock.On("DeleteComment", ctx, commentID)}
}

func (_c *MockDetectionRepository_DeleteComment_Call) Run(run func(ctx context.Context, commentID uint)) *MockDetectionRepository_DeleteComment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint))
	})
	return _c
}

func (_c *MockDetectionRepository_DeleteComment_Call) Return(_a0 error) *MockDetectionRepository_DeleteComment_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDetectionRepository_DeleteComment_Call) RunAndReturn(run func(context.Context, uint) error) *MockDetectionRepository_DeleteComment_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: ctx, id
func (_m *MockDetectionRepository) Get(ctx context.Context, id string) (*detection.Result, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *detection.Result
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*detection.Result, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *detection.Result); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*detection.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDetectionRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockDetectionRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockDetectionRepository_Expecter) Get(ctx interface{}, id interface{}) *MockDetectionRepository_Get_Call {
	return &MockDetectionRepository_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockDetectionRepository_Get_Call) Run(run func(ctx context.Context, id string)) *MockDetectionRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDetectionRepository_Get_Call) Return(_a0 *detection.Result, _a1 error) *MockDetectionRepository_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDetectionRepository_Get_Call) RunAndReturn(run func(context.Context, string) (*detection.Result, error)) *MockDetectionRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetAdditionalResults provides a mock function with given fields: ctx, id
func (_m *MockDetectionRepository) GetAdditionalResults(ctx context.Context, id string) ([]detection.AdditionalResult, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetAdditionalResults")
	}

	var r0 []detection.AdditionalResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]detection.AdditionalResult, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []detection.AdditionalResult); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]detection.AdditionalResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDetectionRepository_GetAdditionalResults_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAdditionalResults'
type MockDetectionRepository_GetAdditionalResults_Call struct {
	*mock.Call
}

// GetAdditionalResults is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockDetectionRepository_Expecter) GetAdditionalResults(ctx interface{}, id interface{}) *MockDetectionRepository_GetAdditionalResults_Call {
	return &MockDetectionRepository_GetAdditionalResults_Call{Call: _e.mock.On("GetAdditionalResults", ctx, id)}
}

func (_c *MockDetectionRepository_GetAdditionalResults_Call) Run(run func(ctx context.Context, id string)) *MockDetectionRepository_GetAdditionalResults_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDetectionRepository_GetAdditionalResults_Call) Return(_a0 []detection.AdditionalResult, _a1 error) *MockDetectionRepository_GetAdditionalResults_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDetectionRepository_GetAdditionalResults_Call) RunAndReturn(run func(context.Context, string) ([]detection.AdditionalResult, error)) *MockDetectionRepository_GetAdditionalResults_Call {
	_c.Call.Return(run)
	return _c
}

// GetByDateRange provides a mock function with given fields: ctx, startDate, endDate, limit, offset
func (_m *MockDetectionRepository) GetByDateRange(ctx context.Context, startDate string, endDate string, limit int, offset int) ([]*detection.Result, int64, error) {
	ret := _m.Called(ctx, startDate, endDate, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for GetByDateRange")
	}

	var r0 []*detection.Result
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, int) ([]*detection.Result, int64, error)); ok {
		return rf(ctx, startDate, endDate, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, int) []*detection.Result); ok {
		r0 = rf(ctx, startDate, endDate, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*detection.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, int, int) int64); ok {
		r1 = rf(ctx, startDate, endDate, limit, offset)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, int, int) error); ok {
		r2 = rf(ctx, startDate, endDate, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDetectionRepository_GetByDateRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByDateRange'
type MockDetectionRepository_GetByDateRange_Call struct {
	*mock.Call
}

// GetByDateRange is a helper method to define mock.On call
//   - ctx context.Context
//   - startDate string
//   - endDate string
//   - limit int
//   - offset int
func (_e *MockDetectionRepository_Expecter) GetByDateRange(ctx interface{}, startDate interface{}, endDate interface{}, limit interface{}, offset interface{}) *MockDetectionRepository_GetByDateRange_Call {
	return &MockDetectionRepository_GetByDateRange_Call{Call: _e.mock.On("GetByDateRange", ctx, startDate, endDate, limit, offset)}
}

func (_c *MockDetectionRepository_GetByDateRange_Call) Run(run func(ctx context.Context, startDate string, endDate string, limit int, offset int)) *MockDetectionRepository_GetByDateRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int), args[4].(int))
	})
	return _c
}

func (_c *MockDetectionRepository_GetByDateRange_Call) Return(_a0 []*detection.Result, _a1 int64, _a2 error) *MockDetectionRepository_GetByDateRange_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDetectionRepository_GetByDateRange_Call) RunAndReturn(run func(context.Context, string, string, int, int) ([]*detection.Result, int64, error)) *MockDetectionRepository_GetByDateRange_Call {
	_c.Call.Return(run)
	return _c
}

// GetBySpecies provides a mock function with given fields: ctx, species, filters
func (_m *MockDetectionRepository) GetBySpecies(ctx context.Context, species string, filters *datastore.DetectionFilters) ([]*detection.Result, int64, error) {
	ret := _m.Called(ctx, species, filters)

	if len(ret) == 0 {
		panic("no return value specified for GetBySpecies")
	}

	var r0 []*detection.Result
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *datastore.DetectionFilters) ([]*detection.Result, int64, error)); ok {
		return rf(ctx, species, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *datastore.DetectionFilters) []*detection.Result); ok {
		r0 = rf(ctx, species, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*detection.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *datastore.DetectionFilters) int64); ok {
		r1 = rf(ctx, species, filters)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, *datastore.DetectionFilters) error); ok {
		r2 = rf(ctx, species, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDetectionRepository_GetBySpecies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBySpecies'
type MockDetectionRepository_GetBySpecies_Call struct {
	*mock.Call
}

// GetBySpecies is a helper method to define mock.On call
//   - ctx context.Context
//   - species string
//   - filters *datastore.DetectionFilters
func (_e *MockDetectionRepository_Expecter) GetBySpecies(ctx interface{}, species interface{}, filters interface{}) *MockDetectionRepository_GetBySpecies_Call {
	return &MockDetectionRepository_GetBySpecies_Call{Call: _e.mock.On("GetBySpecies", ctx, species, filters)}
}

func (_c *MockDetectionRepository_GetBySpecies_Call) Run(run func(ctx context.Context, species string, filters *datastore.DetectionFilters)) *MockDetectionRepository_GetBySpecies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*datastore.DetectionFilters))
	})
	return _c
}

func (_c *MockDetectionRepository_GetBySpecies_Call) Return(_a0 []*detection.Result, _a1 int64, _a2 error) *MockDetectionRepository_GetBySpecies_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDetectionRepository_GetBySpecies_Call) RunAndReturn(run func(context.Context, string, *datastore.DetectionFilters) ([]*detection.Result, int64, error)) *MockDetectionRepository_GetBySpecies_Call {
	_c.Call.Return(run)
	return _c
}

// GetClipPath provides a mock function with given fields: ctx, id
func (_m *MockDetectionRepository) GetClipPath(ctx context.Context, id string) (string, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetClipPath")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDetectionRepository_GetClipPath_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClipPath'
type MockDetectionRepository_GetClipPath_Call struct {
	*mock.Call
}

// GetClipPath is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockDetectionRepository_Expecter) GetClipPath(ctx interface{}, id interface{}) *MockDetectionRepository_GetClipPath_Call {
	return &MockDetectionRepository_GetClipPath_Call{Call: _e.mock.On("GetClipPath", ctx, id)}
}

func (_c *MockDetectionRepository_GetClipPath_Call) Run(run func(ctx context.Context, id string)) *MockDetectionRepository_GetClipPath_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDetectionRepository_GetClipPath_Call) Return(_a0 string, _a1 error) *MockDetectionRepository_GetClipPath_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDetectionRepository_GetClipPath_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockDetectionRepository_GetClipPath_Call {
	_c.Call.Return(run)
	return _c
}

// GetComments provides a mock function with given fields: ctx, id
func (_m *MockDetectionRepository) GetComments(ctx context.Context, id string) ([]detection.Comment, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetComments")
	}

	var r0 []detection.Comment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]detection.Comment, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []detection.Comment); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]detection.Comment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDetectionRepository_GetComments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetComments'
type MockDetectionRepository_GetComments_Call struct {
	*mock.Call
}

// GetComments is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockDetectionRepository_Expecter) GetComments(ctx interface{}, id interface{}) *MockDetectionRepository_GetComments_Call {
	return &MockDetectionRepository_GetComments_Call{Call: _e.mock.On("GetComments", ctx, id)}
}

func (_c *MockDetectionRepository_GetComments_Call) Run(run func(ctx context.Context, id string)) *MockDetectionRepository_GetComments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDetectionRepository_GetComments_Call) Return(_a0 []detection.Comment, _a1 error) *MockDetectionRepository_GetComments_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDetectionRepository_GetComments_Call) RunAndReturn(run func(context.Context, string) ([]detection.Comment, error)) *MockDetectionRepository_GetComments_Call {
	_c.Call.Return(run)
	return _c
}

// GetHourly provides a mock function with given fields: ctx, date, hour, duration, limit, offset
func (_m *MockDetectionRepository) GetHourly(ctx context.Context, date string, hour string, duration int, limit int, offset int) ([]*detection.Result, int64, error) {
	ret := _m.Called(ctx, date, hour, duration, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for GetHourly")
	}

	var r0 []*detection.Result
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, int, int) ([]*detection.Result, int64, error)); ok {
		return rf(ctx, date, hour, duration, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, int, int) []*detection.Result); ok {
		r0 = rf(ctx, date, hour, duration, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*detection.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, int, int, int) int64); ok {
		r1 = rf(ctx, date, hour, duration, limit, offset)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, int, int, int) error); ok {
		r2 = rf(ctx, date, hour, duration, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDetectionRepository_GetHourly_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHourly'
type MockDetectionRepository_GetHourly_Call struct {
	*mock.Call
}

// GetHourly is a helper method to define mock.On call
//   - ctx context.Context
//   - date string
//   - hour string
//   - duration int
//   - limit int
//   - offset int
func (_e *MockDetectionRepository_Expecter) GetHourly(ctx interface{}, date interface{}, hour interface{}, duration interface{}, limit interface{}, offset interface{}) *MockDetectionRepository_GetHourly_Call {
	return &MockDetectionRepository_GetHourly_Call{Call: _e.mock.On("GetHourly", ctx, date, hour, duration, limit, offset)}
}

func (_c *MockDetectionRepository_GetHourly_Call) Run(run func(ctx context.Context, date string, hour string, duration int, limit int, offset int)) *MockDetectionRepository_GetHourly_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int), args[4].(int), args[5].(int))
	})
	return _c
}

func (_c *MockDetectionRepository_GetHourly_Call) Return(_a0 []*detection.Result, _a1 int64, _a2 error) *MockDetectionRepository_GetHourly_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDetectionRepository_GetHourly_Call) RunAndReturn(run func(context.Context, string, string, int, int, int) ([]*detection.Result, int64, error)) *MockDetectionRepository_GetHourly_Call {
	_c.Call.Return(run)
	return _c
}

// GetRecent provides a mock function with given fields: ctx, limit
func (_m *MockDetectionRepository) GetRecent(ctx context.Context, limit int) ([]*detection.Result, error) {
	ret := _m.Called(ctx, limit)

	if len(ret) == 0 {
		panic("no return value specified for GetRecent")
	}

	var r0 []*detection.Result
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]*detection.Result, error)); ok {
		return rf(ctx, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []*detection.Result); ok {
		r0 = rf(ctx, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*detection.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDetectionRepository_GetRecent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRecent'
type MockDetectionRepository_GetRecent_Call struct {
	*mock.Call
}

// GetRecent is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
func (_e *MockDetectionRepository_Expecter) GetRecent(ctx interface{}, limit interface{}) *MockDetectionRepository_GetRecent_Call {
	return &MockDetectionRepository_GetRecent_Call{Call: _e.mock.On("GetRecent", ctx, limit)}
}

func (_c *MockDetectionRepository_GetRecent_Call) Run(run func(ctx context.Context, limit int)) *MockDetectionRepository_GetRecent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockDetectionRepository_GetRecent_Call) Return(_a0 []*detection.Result, _a1 error) *MockDetectionRepository_GetRecent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDetectionRepository_GetRecent_Call) RunAndReturn(run func(context.Context, int) ([]*detection.Result, error)) *MockDetectionRepository_GetRecent_Call {
	_c.Call.Return(run)
	return _c
}

// GetReview provides a mock function with given fields: ctx, id
func (_m *MockDetectionRepository) GetReview(ctx context.Context, id string) (string, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetReview")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDetectionRepository_GetReview_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReview'
type MockDetectionRepository_GetReview_Call struct {
	*mock.Call
}

// GetReview is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockDetectionRepository_Expecter) GetReview(ctx interface{}, id interface{}) *MockDetectionRepository_GetReview_Call {
	return &MockDetectionRepository_GetReview_Call{Call: _e.mock.On("GetReview", ctx, id)}
}

func (_c *MockDetectionRepository_GetReview_Call) Run(run func(ctx context.Context, id string)) *MockDetectionRepository_GetReview_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDetectionRepository_GetReview_Call) Return(_a0 string, _a1 error) *MockDetectionRepository_GetReview_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDetectionRepository_GetReview_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockDetectionRepository_GetReview_Call {
	_c.Call.Return(run)
	return _c
}

// IsLocked provides a mock function with given fields: ctx, id
func (_m *MockDetectionRepository) IsLocked(ctx context.Context, id string) (bool, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for IsLocked")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDetectionRepository_IsLocked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsLocked'
type MockDetectionRepository_IsLocked_Call struct {
	*mock.Call
}

// IsLocked is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockDetectionRepository_Expecter) IsLocked(ctx interface{}, id interface{}) *MockDetectionRepository_IsLocked_Call {
	return &MockDetectionRepository_IsLocked_Call{Call: _e.mock.On("IsLocked", ctx, id)}
}

func (_c *MockDetectionRepository_IsLocked_Call) Run(run func(ctx context.Context, id string)) *MockDetectionRepository_IsLocked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDetectionRepository_IsLocked_Call) Return(_a0 bool, _a1 error) *MockDetectionRepository_IsLocked_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDetectionRepository_IsLocked_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *MockDetectionRepository_IsLocked_Call {
	_c.Call.Return(run)
	return _c
}

// Lock provides a mock function with given fields: ctx, id
func (_m *MockDetectionRepository) Lock(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Lock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDetectionRepository_Lock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Lock'
type MockDetectionRepository_Lock_Call struct {
	*mock.Call
}

// Lock is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockDetectionRepository_Expecter) Lock(ctx interface{}, id interface{}) *MockDetectionRepository_Lock_Call {
	return &MockDetectionRepository_Lock_Call{Call: _e.mock.On("Lock", ctx, id)}
}

func (_c *MockDetectionRepository_Lock_Call) Run(run func(ctx context.Context, id string)) *MockDetectionRepository_Lock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDetectionRepository_Lock_Call) Return(_a0 error) *MockDetectionRepository_Lock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDetectionRepository_Lock_Call) RunAndReturn(run func(context.Context, string) error) *MockDetectionRepository_Lock_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields: ctx, result, additionalResults
func (_m *MockDetectionRepository) Save(ctx context.Context, result *detection.Result, additionalResults []detection.AdditionalResult) error {
	ret := _m.Called(ctx, result, additionalResults)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *detection.Result, []detection.AdditionalResult) error); ok {
		r0 = rf(ctx, result, additionalResults)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDetectionRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockDetectionRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - result *detection.Result
//   - additionalResults []detection.AdditionalResult
func (_e *MockDetectionRepository_Expecter) Save(ctx interface{}, result interface{}, additionalResults interface{}) *MockDetectionRepository_Save_Call {
	return &MockDetectionRepository_Save_Call{Call: _e.mock.On("Save", ctx, result, additionalResults)}
}

func (_c *MockDetectionRepository_Save_Call) Run(run func(ctx context.Context, result *detection.Result, additionalResults []detection.AdditionalResult)) *MockDetectionRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*detection.Result), args[2].([]detection.AdditionalResult))
	})
	return _c
}

func (_c *MockDetectionRepository_Save_Call) Return(_a0 error) *MockDetectionRepository_Save_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDetectionRepository_Save_Call) RunAndReturn(run func(context.Context, *detection.Result, []detection.AdditionalResult) error) *MockDetectionRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// Search provides a mock function with given fields: ctx, filters
func (_m *MockDetectionRepository) Search(ctx context.Context, filters *datastore.DetectionFilters) ([]*detection.Result, int64, error) {
	ret := _m.Called(ctx, filters)

	if len(ret) == 0 {
		panic("no return value specified for Search")
	}

	var r0 []*detection.Result
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *datastore.DetectionFilters) ([]*detection.Result, int64, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *datastore.DetectionFilters) []*detection.Result); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*detection.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *datastore.DetectionFilters) int64); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *datastore.DetectionFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDetectionRepository_Search_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Search'
type MockDetectionRepository_Search_Call struct {
	*mock.Call
}

// Search is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *datastore.DetectionFilters
func (_e *MockDetectionRepository_Expecter) Search(ctx interface{}, filters interface{}) *MockDetectionRepository_Search_Call {
	return &MockDetectionRepository_Search_Call{Call: _e.mock.On("Search", ctx, filters)}
}

func (_c *MockDetectionRepository_Search_Call) Run(run func(ctx context.Context, filters *datastore.DetectionFilters)) *MockDetectionRepository_Search_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*datastore.DetectionFilters))
	})
	return _c
}

func (_c *MockDetectionRepository_Search_Call) Return(_a0 []*detection.Result, _a1 int64, _a2 error) *MockDetectionRepository_Search_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDetectionRepository_Search_Call) RunAndReturn(run func(context.Context, *datastore.DetectionFilters) ([]*detection.Result, int64, error)) *MockDetectionRepository_Search_Call {
	_c.Call.Return(run)
	return _c
}

// SetReview provides a mock function with given fields: ctx, id, verified
func (_m *MockDetectionRepository) SetReview(ctx context.Context, id string, verified string) error {
	ret := _m.Called(ctx, id, verified)

	if len(ret) == 0 {
		panic("no return value specified for SetReview")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, id, verified)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDetectionRepository_SetReview_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetReview'
type MockDetectionRepository_SetReview_Call struct {
	*mock.Call
}

// SetReview is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - verified string
func (_e *MockDetectionRepository_Expecter) SetReview(ctx interface{}, id interface{}, verified interface{}) *MockDetectionRepository_SetReview_Call {
	return &MockDetectionRepository_SetReview_Call{Call: _e.mock.On("SetReview", ctx, id, verified)}
}

func (_c *MockDetectionRepository_SetReview_Call) Run(run func(ctx context.Context, id string, verified string)) *MockDetectionRepository_SetReview_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockDetectionRepository_SetReview_Call) Return(_a0 error) *MockDetectionRepository_SetReview_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDetectionRepository_SetReview_Call) RunAndReturn(run func(context.Context, string, string) error) *MockDetectionRepository_SetReview_Call {
	_c.Call.Return(run)
	return _c
}

// Unlock provides a mock function with given fields: ctx, id
func (_m *MockDetectionRepository) Unlock(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Unlock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDetectionRepository_Unlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unlock'
type MockDetectionRepository_Unlock_Call struct {
	*mock.Call
}

// Unlock is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockDetectionRepository_Expecter) Unlock(ctx interface{}, id interface{}) *MockDetectionRepository_Unlock_Call {
	return &MockDetectionRepository_Unlock_Call{Call: _e.mock.On("Unlock", ctx, id)}
}

func (_c *MockDetectionRepository_Unlock_Call) Run(run func(ctx context.Context, id string)) *MockDetectionRepository_Unlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDetectionRepository_Unlock_Call) Return(_a0 error) *MockDetectionRepository_Unlock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDetectionRepository_Unlock_Call) RunAndReturn(run func(context.Context, string) error) *MockDetectionRepository_Unlock_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateComment provides a mock function with given fields: ctx, commentID, entry
func (_m *MockDetectionRepository) UpdateComment(ctx context.Context, commentID uint, entry string) error {
	ret := _m.Called(ctx, commentID, entry)

	if len(ret) == 0 {
		panic("no return value specified for UpdateComment")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, string) error); ok {
		r0 = rf(ctx, commentID, entry)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDetectionRepository_UpdateComment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateComment'
type MockDetectionRepository_UpdateComment_Call struct {
	*mock.Call
}

// UpdateComment is a helper method to define mock.On call
//   - ctx context.Context
//   - commentID uint
//   - entry string
func (_e *MockDetectionRepository_Expecter) UpdateComment(ctx interface{}, commentID interface{}, entry interface{}) *MockDetectionRepository_UpdateComment_Call {
	return &MockDetectionRepository_UpdateComment_Call{Call: _e.mock.On("UpdateComment", ctx, commentID, entry)}
}

func (_c *MockDetectionRepository_UpdateComment_Call) Run(run func(ctx context.Context, commentID uint, entry string)) *MockDetectionRepository_UpdateComment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(string))
	})
	return _c
}

func (_c *MockDetectionRepository_UpdateComment_Call) Return(_a0 error) *MockDetectionRepository_UpdateComment_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDetectionRepository_UpdateComment_Call) RunAndReturn(run func(context.Context, uint, string) error) *MockDetectionRepository_UpdateComment_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockDetectionRepository creates a new instance of MockDetectionRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDetectionRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockDetectionRepository {
	mock := &MockDetectionRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
